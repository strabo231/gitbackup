#!/bin/bash

# GitBackup - Automated Git Repository Backup Manager
# Version: 1.0.0

set -e

VERSION="1.0.0"
SCRIPT_NAME="gitbackup"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Print colored output
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_error() { echo -e "${RED}✗${NC} $1"; }
print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
print_header() { echo -e "${CYAN}${1}${NC}"; }

# Config file location
CONFIG_FILE="$HOME/.config/gitbackup/config"
BACKUP_LOG="$HOME/.config/gitbackup/backup.log"

# Ensure config directory exists
mkdir -p "$(dirname "$CONFIG_FILE")"

# Show usage
show_usage() {
    cat << EOF
${BLUE}GitBackup${NC} - Automated Git Repository Backup Manager v${VERSION}

${YELLOW}Usage:${NC}
    $SCRIPT_NAME <command> [options]

${YELLOW}Commands:${NC}
    scan <directory>         Scan for git repositories
    list                     List all discovered repositories
    backup [options]         Backup all repositories
    status                   Show backup status for all repos
    restore <backup> [dest]  Restore from backup
    config                   Show/edit configuration
    log                      Show backup history
    clean                    Clean old backups

${YELLOW}Backup Options:${NC}
    -d, --destination <dir>  Backup destination directory
    -c, --compress           Compress backups (tar.gz)
    -i, --incremental        Only backup repos with changes
    -f, --force              Backup even if no changes
    --exclude <pattern>      Exclude repos matching pattern

${YELLOW}General Options:${NC}
    -h, --help              Show this help message
    -v, --version           Show version information
    -q, --quiet             Suppress non-error output

${YELLOW}Examples:${NC}
    $SCRIPT_NAME scan ~/Projects
        → Scan ~/Projects for git repositories

    $SCRIPT_NAME list
        → Show all discovered repositories

    $SCRIPT_NAME backup -d /media/backup
        → Backup all repos to /media/backup

    $SCRIPT_NAME backup -d /media/backup --compress
        → Backup all repos as compressed archives

    $SCRIPT_NAME backup -d /media/backup --incremental
        → Only backup repos that have changed

    $SCRIPT_NAME status
        → Show which repos need backing up

    $SCRIPT_NAME restore /media/backup/myrepo.tar.gz ~/restored
        → Restore a repository from backup

${YELLOW}Configuration:${NC}
    Config file: $CONFIG_FILE
    Backup log:  $BACKUP_LOG

${YELLOW}Typical Workflow:${NC}
    1. Scan for repos:     $SCRIPT_NAME scan ~/Projects ~/Work
    2. Check what's found: $SCRIPT_NAME list
    3. Backup everything:  $SCRIPT_NAME backup -d /media/backup
    4. Check status:       $SCRIPT_NAME status

EOF
}

# Show version
show_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Load configuration
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    fi
}

# Save repository list
save_repo_list() {
    local repo_file="$HOME/.config/gitbackup/repositories.txt"
    printf "%s\n" "${REPOS[@]}" > "$repo_file"
    print_success "Saved ${#REPOS[@]} repositories"
}

# Load repository list
load_repo_list() {
    local repo_file="$HOME/.config/gitbackup/repositories.txt"
    REPOS=()
    
    if [ -f "$repo_file" ]; then
        while IFS= read -r line; do
            [ -n "$line" ] && REPOS+=("$line")
        done < "$repo_file"
    fi
}

# Scan directory for git repositories
scan_repos() {
    local scan_dir="$1"
    
    if [ -z "$scan_dir" ]; then
        print_error "Please specify directory to scan"
        return 1
    fi
    
    if [ ! -d "$scan_dir" ]; then
        print_error "Directory not found: $scan_dir"
        return 1
    fi
    
    print_header "═══════════════════════════════════════════════════════════════"
    print_header "              SCANNING FOR GIT REPOSITORIES"
    print_header "═══════════════════════════════════════════════════════════════"
    echo ""
    print_info "Scanning: $scan_dir"
    echo ""
    
    # Load existing repos
    load_repo_list
    local initial_count=${#REPOS[@]}
    
    # Find all .git directories
    while IFS= read -r git_dir; do
        local repo_path=$(dirname "$git_dir")
        
        # Check if already in list
        local found=false
        for existing in "${REPOS[@]}"; do
            if [ "$existing" = "$repo_path" ]; then
                found=true
                break
            fi
        done
        
        if [ "$found" = false ]; then
            REPOS+=("$repo_path")
            print_success "Found: $repo_path"
        fi
    done < <(find "$scan_dir" -type d -name ".git" 2>/dev/null)
    
    local new_count=$((${#REPOS[@]} - initial_count))
    
    echo ""
    print_header "═══════════════════════════════════════════════════════════════"
    print_success "Found $new_count new repositories"
    print_info "Total repositories tracked: ${#REPOS[@]}"
    print_header "═══════════════════════════════════════════════════════════════"
    echo ""
    
    save_repo_list
}

# List all tracked repositories
list_repos() {
    load_repo_list
    
    if [ ${#REPOS[@]} -eq 0 ]; then
        print_warning "No repositories tracked"
        echo ""
        print_info "Run '$SCRIPT_NAME scan <directory>' to find repositories"
        return
    fi
    
    print_header "═══════════════════════════════════════════════════════════════"
    print_header "                  TRACKED REPOSITORIES"
    print_header "═══════════════════════════════════════════════════════════════"
    echo ""
    
    local count=0
    for repo in "${REPOS[@]}"; do
        ((count++))
        
        if [ ! -d "$repo" ]; then
            echo -e "${RED}[$count]${NC} ${RED}[NOT FOUND]${NC} $repo"
            continue
        fi
        
        cd "$repo"
        
        # Get repo name
        local repo_name=$(basename "$repo")
        
        # Check for uncommitted changes
        local status=""
        if git rev-parse HEAD >/dev/null 2>&1; then
            # Repo has commits
            if ! git diff-index --quiet HEAD -- 2>/dev/null; then
                status="${RED}[UNCOMMITTED CHANGES]${NC}"
            elif [ -n "$(git status --porcelain 2>/dev/null)" ]; then
                status="${YELLOW}[UNTRACKED FILES]${NC}"
            else
                status="${GREEN}[CLEAN]${NC}"
            fi
        else
            # New repo with no commits yet
            status="${YELLOW}[NEW REPO]${NC}"
        fi
            status="${YELLOW}[UNTRACKED FILES]${NC}"
        else
            status="${GREEN}[CLEAN]${NC}"
        fi
        
        # Get last commit date
        local last_commit=$(git log -1 --format="%ar" 2>/dev/null || echo "unknown")
        
        # Get branch
        local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
        
        echo -e "${CYAN}[$count]${NC} $status"
        echo "     Path:   $repo"
        echo "     Branch: $branch"
        echo "     Last:   $last_commit"
        echo ""
    done
    
    print_header "═══════════════════════════════════════════════════════════════"
    print_info "Total: ${#REPOS[@]} repositories"
    print_header "═══════════════════════════════════════════════════════════════"
}

# Get repository status
get_repo_status() {
    local repo="$1"
    
    cd "$repo"
    
    # Check if repo has any commits
    if ! git rev-parse HEAD >/dev/null 2>&1; then
        echo "NEW"
        return
    fi
    
    # Check if there are uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        echo "UNCOMMITTED"
        return
    fi
    
    # Check if there are untracked files
    if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
        echo "UNTRACKED"
        return
    fi
    
    echo "CLEAN"
}

# Calculate directory size
get_dir_size() {
    du -sh "$1" 2>/dev/null | cut -f1 || echo "unknown"
}

# Backup single repository
backup_repo() {
    local repo="$1"
    local dest="$2"
    local compress="$3"
    local incremental="$4"
    
    if [ ! -d "$repo" ]; then
        print_error "Repository not found: $repo"
        return 1
    fi
    
    local repo_name=$(basename "$repo")
    local timestamp=$(date +%Y%m%d_%H%M%S)
    
    cd "$repo"
    
    # Check for uncommitted changes
    local status=$(get_repo_status "$repo")
    if [ "$status" = "UNCOMMITTED" ]; then
        print_warning "$repo_name has uncommitted changes!"
    fi
    
    # Check if backup needed (incremental mode)
    if [ "$incremental" = true ]; then
        local backup_marker="$dest/.${repo_name}.last_backup"
        if [ -f "$backup_marker" ]; then
            local last_commit_backed=$(cat "$backup_marker")
            local current_commit=$(git rev-parse HEAD 2>/dev/null)
            
            if [ "$last_commit_backed" = "$current_commit" ]; then
                print_info "$repo_name: No changes since last backup (skipped)"
                return 0
            fi
        fi
    fi
    
    print_info "Backing up: $repo_name"
    
    if [ "$compress" = true ]; then
        # Compressed backup
        local backup_file="$dest/${repo_name}_${timestamp}.tar.gz"
        
        tar -czf "$backup_file" \
            --exclude='.git/objects/pack/*.pack' \
            --exclude='node_modules' \
            --exclude='venv' \
            --exclude='__pycache__' \
            --exclude='.venv' \
            -C "$(dirname "$repo")" "$(basename "$repo")" 2>/dev/null
        
        local size=$(get_dir_size "$backup_file")
        print_success "$repo_name backed up ($size)"
        
    else
        # Direct copy
        local backup_dir="$dest/${repo_name}_${timestamp}"
        
        rsync -a \
            --exclude='.git/objects/pack/*.pack' \
            --exclude='node_modules' \
            --exclude='venv' \
            --exclude='__pycache__' \
            --exclude='.venv' \
            "$repo/" "$backup_dir/" 2>/dev/null
        
        local size=$(get_dir_size "$backup_dir")
        print_success "$repo_name backed up ($size)"
    fi
    
    # Update backup marker
    git rev-parse HEAD 2>/dev/null > "$dest/.${repo_name}.last_backup"
    
    # Log backup
    echo "$(date '+%Y-%m-%d %H:%M:%S') | $repo_name | SUCCESS" >> "$BACKUP_LOG"
}

# Backup all repositories
backup_all() {
    local destination=""
    local compress=false
    local incremental=false
    local force=false
    local exclude_pattern=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--destination)
                destination="$2"
                shift 2
                ;;
            -c|--compress)
                compress=true
                shift
                ;;
            -i|--incremental)
                incremental=true
                shift
                ;;
            -f|--force)
                force=true
                shift
                ;;
            --exclude)
                exclude_pattern="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [ -z "$destination" ]; then
        print_error "Please specify backup destination with -d or --destination"
        return 1
    fi
    
    if [ ! -d "$destination" ]; then
        print_warning "Destination directory doesn't exist: $destination"
        read -p "Create it? (y/N) " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            mkdir -p "$destination"
        else
            return 1
        fi
    fi
    
    load_repo_list
    
    if [ ${#REPOS[@]} -eq 0 ]; then
        print_error "No repositories to backup"
        print_info "Run '$SCRIPT_NAME scan <directory>' first"
        return 1
    fi
    
    print_header "═══════════════════════════════════════════════════════════════"
    print_header "                    STARTING BACKUP"
    print_header "═══════════════════════════════════════════════════════════════"
    echo ""
    print_info "Destination: $destination"
    print_info "Repositories: ${#REPOS[@]}"
    print_info "Compress: $compress"
    print_info "Incremental: $incremental"
    echo ""
    
    local success=0
    local skipped=0
    local failed=0
    
    for repo in "${REPOS[@]}"; do
        # Check exclude pattern
        if [ -n "$exclude_pattern" ] && [[ $repo =~ $exclude_pattern ]]; then
            ((skipped++))
            continue
        fi
        
        if backup_repo "$repo" "$destination" "$compress" "$incremental"; then
            ((success++))
        else
            ((failed++))
        fi
    done
    
    echo ""
    print_header "═══════════════════════════════════════════════════════════════"
    print_header "                   BACKUP COMPLETE"
    print_header "═══════════════════════════════════════════════════════════════"
    echo ""
    print_success "Successfully backed up: $success"
    [ $skipped -gt 0 ] && print_info "Skipped: $skipped"
    [ $failed -gt 0 ] && print_error "Failed: $failed"
    echo ""
}

# Show backup status
show_status() {
    load_repo_list
    
    if [ ${#REPOS[@]} -eq 0 ]; then
        print_warning "No repositories tracked"
        return
    fi
    
    print_header "═══════════════════════════════════════════════════════════════"
    print_header "                   BACKUP STATUS"
    print_header "═══════════════════════════════════════════════════════════════"
    echo ""
    
    local needs_backup=0
    
    for repo in "${REPOS[@]}"; do
        if [ ! -d "$repo" ]; then
            continue
        fi
        
        local repo_name=$(basename "$repo")
        local status=$(get_repo_status "$repo")
        
        cd "$repo"
        local last_commit_date=$(git log -1 --format="%ar" 2>/dev/null || echo "unknown")
        
        if [ "$status" = "UNCOMMITTED" ]; then
            echo -e "${RED}⚠${NC} $repo_name"
            echo "   Status: Uncommitted changes"
            echo "   Last commit: $last_commit_date"
            echo "   ${RED}Needs backup!${NC}"
            ((needs_backup++))
        elif [ "$status" = "UNTRACKED" ]; then
            echo -e "${YELLOW}⚠${NC} $repo_name"
            echo "   Status: Untracked files"
            echo "   Last commit: $last_commit_date"
            echo "   ${YELLOW}Consider backing up${NC}"
            ((needs_backup++))
        else
            echo -e "${GREEN}✓${NC} $repo_name"
            echo "   Status: Clean"
            echo "   Last commit: $last_commit_date"
        fi
        echo ""
    done
    
    print_header "═══════════════════════════════════════════════════════════════"
    if [ $needs_backup -gt 0 ]; then
        print_warning "$needs_backup repositories need attention"
    else
        print_success "All repositories are clean"
    fi
    print_header "═══════════════════════════════════════════════════════════════"
}

# Restore from backup
restore_backup() {
    local backup_file="$1"
    local restore_dest="$2"
    
    if [ -z "$backup_file" ]; then
        print_error "Please specify backup file"
        return 1
    fi
    
    if [ ! -f "$backup_file" ]; then
        print_error "Backup file not found: $backup_file"
        return 1
    fi
    
    if [ -z "$restore_dest" ]; then
        restore_dest="."
    fi
    
    print_info "Restoring: $backup_file"
    print_info "Destination: $restore_dest"
    
    if [[ $backup_file == *.tar.gz ]]; then
        tar -xzf "$backup_file" -C "$restore_dest"
    else
        print_error "Unsupported backup format"
        return 1
    fi
    
    print_success "Restore complete"
}

# Show backup log
show_log() {
    if [ ! -f "$BACKUP_LOG" ]; then
        print_info "No backup history yet"
        return
    fi
    
    print_header "═══════════════════════════════════════════════════════════════"
    print_header "                   BACKUP HISTORY"
    print_header "═══════════════════════════════════════════════════════════════"
    echo ""
    
    tail -n 50 "$BACKUP_LOG"
    
    echo ""
    print_info "Showing last 50 entries"
    print_info "Full log: $BACKUP_LOG"
}

# Main command handling
if [ $# -eq 0 ]; then
    show_usage
    exit 0
fi

COMMAND="$1"
shift

case "$COMMAND" in
    scan)
        scan_repos "$@"
        ;;
    list|ls)
        list_repos
        ;;
    backup)
        backup_all "$@"
        ;;
    status)
        show_status
        ;;
    restore)
        restore_backup "$@"
        ;;
    log)
        show_log
        ;;
    -h|--help)
        show_usage
        ;;
    -v|--version)
        show_version
        ;;
    *)
        print_error "Unknown command: $COMMAND"
        echo "Use -h or --help for usage information"
        exit 1
        ;;
esac
